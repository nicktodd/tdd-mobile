//
//  UserListViewModel.swift
//  MVVMExample
//
//  Created by Nick Todd on 23/10/2025.
//

import Foundation
import SwiftUI
import Combine

/**
 * USER LIST VIEW MODEL
 *
 * This is the ViewModel in the MVVM pattern. It acts as the binding layer between
 * the View (UI) and the Model (data/business logic).
 *
 * Key responsibilities of a ViewModel:
 * 1. PRESENTATION LOGIC: Transforms model data for display
 * 2. STATE MANAGEMENT: Manages UI state and user interactions
 * 3. BUSINESS LOGIC: Coordinates operations between UI and data layer
 * 4. DATA BINDING: Provides observable properties for the UI
 * 5. INPUT HANDLING: Processes user actions and commands
 *
 * Why ObservableObject?
 * - Integrates with SwiftUI's reactive system
 * - Automatically triggers UI updates when @Published properties change
 * - Follows the Observer pattern for loose coupling
 *
 * Note: Using @MainActor ensures all UI updates happen on the main thread
 * but we need to be careful with SwiftUI integration. For iOS 15+, we can 
 * use @MainActor with ObservableObject, but we need to ensure proper setup.
 */
class UserListViewModel: ObservableObject {
    
    // MARK: - Published Properties (Observable State)
    
    /**
     * The list of users to display in the UI
     * @Published ensures SwiftUI views automatically update when this changes
     */
    @Published var users: [User] = []
    
    /**
     * Tracks whether the ViewModel is currently performing an operation
     * Useful for showing loading indicators in the UI
     */
    @Published var isLoading: Bool = false
    
    /**
     * Holds any error message to display to the user
     * Optional because most of the time there won't be an error
     */
    @Published var errorMessage: String? = nil
    
    /**
     * Text for adding new users - bound to UI input field
     * Demonstrates two-way data binding in MVVM
     */
    @Published var newUserName: String = ""
    
    // MARK: - Private Properties
    
    /**
     * The repository dependency for data operations
     * Private to ensure encapsulation - only this ViewModel should interact with it
     * Using the protocol allows for easy testing with mocks
     */
    private let repository: UserRepositoryProtocol
    
    // MARK: - Initialization
    
    /**
     * Dependency injection through initializer
     * This is crucial for testability - we can inject mock repositories in tests
     *
     * - Parameter repository: The repository to use for data operations
     */
    init(repository: UserRepositoryProtocol) {
        self.repository = repository
        loadUsers()
    }
    
    // MARK: - Public Methods (Commands/Actions)
    
    /**
     * COMMAND: Load all users from the repository
     * This method demonstrates how ViewModels coordinate between UI and data layer
     */
    func loadUsers() {
        isLoading = true
        errorMessage = nil
        
        // For in-memory repository, this is synchronous
        // In a real app with network/database, you'd use async/await
        users = repository.getAllUsers()
        isLoading = false
    }
    
    /**
     * COMMAND: Add a new user
     * Demonstrates input validation and error handling in ViewModels
     */
    func addUser() {
        // Input validation - ViewModel's responsibility
        guard !newUserName.trimmingCharacters(in: .whitespaces).isEmpty else {
            errorMessage = "User name cannot be empty"
            return
        }
        
        isLoading = true
        errorMessage = nil
        
        // Create new user (ID will be auto-generated by repository)
        let userToAdd = User(id: 0, name: newUserName.trimmingCharacters(in: .whitespaces))
        
        // Perform repository operation
        let addedUser = repository.addUser(userToAdd)
        
        // Update UI state
        users = repository.getAllUsers()
        newUserName = "" // Clear input field
        isLoading = false
    }
    
    /**
     * COMMAND: Delete a user by ID
     * Demonstrates error handling when operations might fail
     *
     * - Parameter userId: The ID of the user to delete
     */
    func deleteUser(withId userId: Int) {
        isLoading = true
        errorMessage = nil
        
        let success = repository.deleteUser(withId: userId)
        
        if success {
            // Refresh the user list to reflect the deletion
            users = repository.getAllUsers()
        } else {
            errorMessage = "Failed to delete user. User not found."
        }
        
        isLoading = false
    }
    
    /**
     * COMMAND: Clear any error message
     * Allows the UI to dismiss error states
     */
    func clearError() {
        errorMessage = nil
    }
    
    // MARK: - Computed Properties (Presentation Logic)
    
    /**
     * Returns whether the add button should be enabled
     * This is presentation logic - transforming model state into UI state
     */
    var canAddUser: Bool {
        return !newUserName.trimmingCharacters(in: .whitespaces).isEmpty && !isLoading
    }
    
    /**
     * Returns a formatted count of users for display
     * Example of how ViewModels format data for presentation
     */
    var userCountText: String {
        let count = users.count
        return count == 1 ? "1 User" : "\(count) Users"
    }
}